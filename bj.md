# 修改国内镜像源

    Windows上通配置文件修改方法
    需要在当前对用户目录下（C:\Users\xx\pip，xx 表示当前使用的系统用户）创建一个 pip.ini在pip.ini文件中输入以下内容：
    [global]
    index-url = https://pypi.tuna.tsinghua.edu.cn/simple
    [install]
    trusted-host = pypi.tuna.tsinghua.edu.cn
    通过pip config list命令查看配置是否修改成功
    上面目录不对，导致源失败
    通过命令
    pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
# 创建虚拟环境
    命令环境下
python -m venv F:\learn\mysite\myenvweb01
python -m venv D:\mysite\myenvweb01
# 激活虚拟环境
    进入虚拟环境目录下的Scripts目录
    

cd F:\learn\mysite\myenvweb01\Scripts
activate
# 退出虚拟环境命令,

deactivate
# 删除虚拟环境,
    直接删除虚拟环境目录
# 进入虚拟环境,安装django
cd F:\learn\mysite\myenvweb01\Scripts
activate
pip install django==3.2
# 创建django项目,在要创建项目的目录中运行下面命令
    cd F:\learn\mysite
    django-admin startproject mywebsite01
# 进入数据库， 密码1234，创建数据库mywebsite01，配置settings.py
mysql -u root -p
show databases;
create database shserver default charset=utf8;
# 安装mysqlclient
pip install mysqlclient
# 创建子应用,配置settings.py
    cd F:\learn\mysite\mywebsite01
    python manage.py startapp users
    python manage.py startapp statements
    python manage.py runserver
# 安装djangorestframework,配置settings.py
pip install djangorestframework
安装django-cors-headers跨域,配置settings.py
pip install django-cors-headers
python -m pip install Pillow

注册跨域'corsheaders'，

配置中间件'corsheaders.middleware.CorsMiddleware',

注释中间件'django.middleware.csrf.CsrfViewMiddleware',

#允许所有的用户跨域请求
CORS_ORIGIN_ALLOW_ALL=True

修改语言
LANGUAGE_CODE = 'zh-hans'

修改时间
TIME_ZONE = 'Asia/Shanghai'
修改django默认ip
使用命令行方式启动项目，并以临时修改的方式设置端口号和 IP 地址。
python manage.py runserver 0.0.0.0:8080

通过修改 Django 项目中的 manage.py 文件来设置端口号和 IP 地址。
需要配置settings 
ALLOWED_HOSTS = ['127.0.0.2']

manage.py 文件中的 main 方法
if __name__ == "__main__":  
    from django.core.management.commands.runserver import Command as Runserver  
    Runserver.default_addr = '0.0.0.0'  # 修改默认地址  
    Runserver.default_port = '8080'  # 修改默认端口  
    main()
# manage.py 文件中的 main 方法
if __name__ == "__main__":  
    from django.core.management.commands.runserver import Command as Runserver  
    Runserver.default_addr = '0.0.0.0'  # 修改默认地址  
    Runserver.default_port = '8080'  # 修改默认端口  
    main()
自定义用户继承from django.contrib.auth.models import AbstractUser时，
需要指定自定义用户类
AUTH_USER_MODEL='users.User'

安装jwt认证，注册jwt,配置REST_FRAMEWORK
配置settings.py
    #设置token有效期

安装过滤,并在settings配置'django_filters',
指定过滤器
REST_FRAMEWORK={
    'DEFAULT_FILTER_BACKENDS':('django_filters.rest_framework.DjangoFilterBackend')
}
pip install djangorestframework-simplejwt
pip install django-filter
配置settings.py如下
#mysite01.settings.py
"""
Django settings for mysite01 project.

Generated by 'django-admin startproject' using Django 4.2.1.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
from datetime import timedelta

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-r9!=tsrdn=m38to0yxo2d5oqet&28_f0y#5+3_=tg2m)6ng86="

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    'rest_framework_simplejwt',
    'django_filters',
    'rest_framework',
    'corsheaders',
    'users',
    "statements",
]

MIDDLEWARE = [
    #配置跨域
    'corsheaders.middleware.CorsMiddleware',
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    # "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    # "users.middlewares.rabc.RabcMiddleware",
]

ROOT_URLCONF = "mysite01.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "mysite01.wsgi.application"


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    "default": {
        #配置数据库
        # 'ENGINE': 'django.db.backends.sqlite3',
        # 'NAME': BASE_DIR / 'db.sqlite3',
        'ENGINE': 'django.db.backends.mysql',
        'HOST':'127.0.0.1',
        'PORT':'3306',
        'USER':'root',
        'PASSWORD':'1234',
        'NAME': 'mywebsite01',
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",},
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

# LANGUAGE_CODE = 'en-us'
LANGUAGE_CODE = 'zh-hans'
# 修改时间
TIME_ZONE = 'Asia/Shanghai'
# TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

#允许所有的用户跨域请求
CORS_ORIGIN_ALLOW_ALL=True
# 指定自定义用户类
AUTH_USER_MODEL='users.User'

REST_FRAMEWORK={
    #jwt认证
    'DEFAULT_AUTHENTICATION_CLASSES':(
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
    'DEFAULT_FILTER_BACKENDS':(
        'django_filters.rest_framework.DjangoFilterBackend',
    )
}
#设置token有效期
SIMPLE_JWT={
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=50),   # 设置token有效时间
    # 'ACCESS_TOKEN_LIFETIME': timedelta(days=7),   # 设置token有效时间
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),  # 刷新token有效时间
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': False,
    # 'UPDATE_LAST_LOGIN': False,  # 设置为True会在用户登录时，更新user表中的last_login字段

    'ALGORITHM': 'HS256',  # 加密算法
    # 'SIGNING_KEY': settings.SECRET_KEY,  # 签名密钥
    'SIGNING_KEY': SECRET_KEY,  # 签名密钥
    'VERIFYING_KEY': None,  # 验证密钥，用于验证生成令牌的内容
    'AUDIENCE': None,  # 设置为None时，此字段将从token中排除，并且不会进行验证
    'ISSUER': None,  # 设置为None时，此字段将从token中排除，并且不会进行验证
    # 'JWK_URL': None,  # 设置为None时，此字段将从token中排除，并且在验证期间不使用
    # 'LEEWAY': 0,  # 用来给到期时间留一些余地

    'AUTH_HEADER_TYPES': ('Bearer',),  # 认证的标签头，类似jwt token中的jwt
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',  # 身份验证的授权标头名称
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',  # 生成token中声明将用于存储用户标识符
    # 'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',

    # 'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    # 'TOKEN_TYPE_CLAIM': 'token_type',  # 用于存储token类型的声明名称

    # 'JTI_CLAIM': 'jti',  # 用于存储令牌的唯一标识符的声明名称

    # 'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    # 'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
    # 'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}
#身份验证，全局设置
AUTHENTICATION_BACKENDS=[
    'common.authentication.Authentication'
]

#文件上传路径
MEDIA_ROOT=BASE_DIR/'file/image/'
#文件获取的url路径
MEDIA_URL='file/image/'

PERMISSION_SESSION_KEY='per'

WHITF_LIST=[
    '^/users/login/$',
    '^/admin/.*$',
    '^/reg/$',
]

#common.db.py
from django.db import models

class BaseModel(models.Model):
    create_time=models.DateTimeField(verbose_name='创建时间',auto_now_add=True)
    update_time=models.DateTimeField(verbose_name='更新时间',auto_now=True)
    is_delete=models.BooleanField(verbose_name='删除标记',default=False)

    class Meta:
        abstract=True
        verbose_name_plural='公共字段表'
        db_table='BaseTable'
#common.views.py
from rest_framework.views import APIView

class NbApiView(APIView):
    def check_permissions(self, request):
        no_permission_objects=[]
        for permission in self.get_permissions():
            if permission.has_permission(request,self):
                return
            else:
                no_permission_objects.append(permission)
        else:
            self.permission_denied(
                request,
                message=getattr(no_permission_objects[0],'message',None),
                code=getattr(no_permission_objects[0],'code',None)
            )
        
#common.authentication.py
from typing import Any
from django.contrib.auth.backends import ModelBackend
from users.models import User
from django.db.models import Q
from rest_framework import serializers

class Authentication(ModelBackend):
    def authenticate(self, request, username=None , password=None, **kwargs: Any):
        
        try:
            user=User.objects.get(Q(username=username)|Q(mobile=username)|Q(email=username))
        except:
            raise serializers.ValidationError({"erroe":"未找到用户"})
        if user.check_password(password):
            return user
        else:
            raise serializers.ValidationError({"erroe":"密码错误"})

数据库迁移命令
python manage.py makemigrations
python manage.py migrate
创建管理员
python manage.py createsuperuser
#mywebsite01.urls.py
"""
URL configuration for mysite01 project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import include, path, re_path

from users.views import FileView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('users/', include('users.urls')),
    re_path('file/image/(.+?)/', FileView.as_view()),
    path('statements/', include('statements.urls')),
]

#users.urls.py
from django.urls import path
from users import views
from rest_framework_simplejwt.views import TokenRefreshView,TokenVerifyView

urlpatterns = [
    path('login/', views.LoginView.as_view()),
    path('register/', views.RegisterViews.as_view()),
    path('token/refresh/',TokenRefreshView.as_view()),
    path('token/verify/',TokenVerifyView.as_view()),
    path('users/<int:pk>/',views.UserView.as_view({'get': 'retrieve'})),
    path('<int:pk>/name/',views.UserView.as_view({'put': 'update_name'})),
    path('<int:pk>/email/',views.UserView.as_view({'put': 'update_email'})),
    path('<int:pk>/password/',views.UserView.as_view({'put': 'update_password'})),
    # path('address/',views.addrview.as_view({'post':'coreate','get':'list'}))
    # path('address/<int:pk>/',views.addrview.as_view({'put':'destroy','delete':'update'}))


]
#users.vises.py
import os
import re
from django.http import FileResponse
from django.shortcuts import render
from rest_framework import mixins
from rest_framework.response import Response
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework_simplejwt.exceptions import TokenError,InvalidToken,status
from rest_framework.views import APIView
from rest_framework.viewsets import ModelViewSet,GenericViewSet
from common.views import NbApiView
from mysite01 import settings
from mysite01.settings import MEDIA_ROOT
from users.models import User
from users.permissions import UserPermissixon,RabcPermissixon
from users.serializers import UserSerializer
from rest_framework.permissions import IsAuthenticated


# Create your views here.

class RegisterViews(APIView):
    def post(self,request):
        username=request.data.get('username')
        password=request.data.get('password')
        email=request.data.get('email')
        password_confirmation=request.data.get('password_confirmation')
        if not all([username,password,email,password_confirmation]):
            return Response({'error':'参数不能为空'},status=status.HTTP_400_BAD_REQUEST)
        if User.objects.filter(username=username).exists():
            return Response({'error':'用户名已存在'},status=status.HTTP_400_BAD_REQUEST)
        if password!=password_confirmation:
            return Response({'error':'两次密码不一致'},status=status.HTTP_400_BAD_REQUEST)
        if not(6<=len(password)<=18):
            return Response({'error':'密码长度应在6至18直接'},status=status.HTTP_400_BAD_REQUEST)
        if User.objects.filter(email=email).exists():
            return Response({'error':'该邮箱已被其他用户使用'},status=status.HTTP_400_BAD_REQUEST)
        # if not re.match(r'^[a-z0-9][\w.\-]*@[a-z0-9\-]+(\.[a-z]{2,5}{1,2}$)',email):
        if not re.match(r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+',email):
            return Response({'error':'邮箱格式有误'},status=status.HTTP_400_BAD_REQUEST)
        obj=User.objects.create_user(username=username,email=email,password=password)
        res={'username':obj.username,'id':obj.id,'email':obj.email}
        return Response(res,status=status.HTTP_201_CREATED)


class LoginView(TokenObtainPairView):
    def post(self, request, *args, **kwargs):
        serializer=self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
        except TokenError as e:
            raise InvalidToken(e.args[0])
        result=serializer.validated_data
        result['id']=serializer.user.id
        result['username']=serializer.user.username
        result['last_name']=serializer.user.last_name
        result['is_superuser']=serializer.user.is_superuser
        result['mobile']=serializer.user.mobile
        result['email']=serializer.user.email
        result['token']=result.pop('access')
        return Response(result,status=status.HTTP_200_OK)
    

#用户表视图，身份验证，权限
class UserView(GenericViewSet,mixins.RetrieveModelMixin):
    queryset=User.objects.all()
    serializer_class=UserSerializer
    permission_classes=[IsAuthenticated,UserPermissixon]

    #文件上传
    def upload_avatar(self,request,*args,**kwargs):
        user=self.get_object()
        avatar=request.data.get('avatar')
        if not avatar:
            return Response({'error':'上传失败，文件不能为空'},status=status.HTTP_400_BAD_REQUEST)
        if avatar.size>1024*300:
            return Response({'error':'上传失败，文件大小不能超过300kb'},status=status.HTTP_400_BAD_REQUEST)
        serializer=self.get_serializer(user,data={'avatar':avatar},partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'url':serializer.data['avatar']})

    def update_name(self,request,*args,**kwargs):
        last_name=request.data.get('last_name')
        if not last_name:
            return Response({'error':'请输入昵称'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        user=self.get_object()
        print(user)
        user.last_name=last_name
        user.save()
        return Response({'msssage':'昵称修改成功'},status=status.HTTP_200_OK)

    def update_email(self,request,*args,**kwargs):
        email=request.data.get('email')
        user=self.get_object()
        if not email:
            return Response({'error':'请输入邮箱'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        if not re.match(r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+',email):
            return Response({'error':'邮箱格式不正确'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        if user.email==email:
            return Response({'message':'与原邮箱一致'},status=status.HTTP_200_OK)
        if User.objects.filter(email=email).exists():
            return Response({'error':'邮箱已存在，更换邮箱'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        user.email=email
        user.save()
        return Response({'message':'邮箱修改成功'},status=status.HTTP_200_OK)

    def update_password(self,request,*args,**kwargs):
        user=self.get_object()
        password=request.data.get('password')
        password_confirmation=request.data.get('password_confirmation')
        if not password:
            return Response({'error':'密码不能为空'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        if password!=password_confirmation:
            return Response({'error':'两次密码不一致'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        if not(6<=len(password)<=18):
            return Response({'error':'密码长度不能小于6大于18位'},status=status.HTTP_422_UNPROCESSABLE_ENTITY)
        user.set_password(password)
        user.save()
        return Response({'message':'密码修改成功'},status=status.HTTP_200_OK)






# #查看图片
# class FileView(APIView):
#     permission_classes=[RabcPermissixon]
#     def get(self,requests,name):
#         path=MEDIA_ROOT/name
#         if os.path.isfile(path):
#             return FileResponse(open(path,'rb'))
#         return Response({'code':"没有此图片"},status=status.HTTP_404_NOT_FOUND)
#查看图片
class FileView(NbApiView):
    permission_classes=[RabcPermissixon]
    def get(self,requests,name):
        path=MEDIA_ROOT/name
        if os.path.isfile(path):
            return FileResponse(open(path,'rb'))
        return Response({'code':"没有此图片"},status=status.HTTP_404_NOT_FOUND)


多字段登录,配置settings

#settings.py
#身份验证，全局设置
AUTHENTICATION_BACKENDS=[
    'common.authentication.Authentication'
]
#users.serializers.py
from rest_framework import serializers
from users.models import User

"""
user表序列化
"""
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model=User
        # fields='__all__'
        fields=['id','username','email','mobile','avatar','last_name']
    
# users.permissions.py
from users.models import User
from rest_framework_simplejwt.backends import TokenBackend
from rest_framework import permissions
from django.conf import settings
import re

"""
用户对user表的数据权限
"""

class UserPermissixon(permissions.BasePermission):

    def has_object_permission(self, request, view, obj):
        if request.user.is_superuser:
            return True
        return obj == request.user


# https://www.cnblogs.com/xiao-xue-di/p/9913104.html


# class RabcMiddleware(MiddlewareMixin):
    # def process_request(self, request):
class RabcPermissixon(permissions.BasePermission):
    message={'msg':'没有权限，联系管理员'}
    def has_permission(self, request, view):
        url = request.path_info
        for i in settings.WHITF_LIST:
            if re.match(i, url):
                return True
        token = request.META.get('HTTP_AUTHORIZATION', " ").split(' ')[1]
        try:
            valid_data = TokenBackend(
                algorithm='HS256').decode(token, verify=False)
            request.user.id = valid_data['user_id']
        except Exception as v:
            print("validation error", v)
        obj = User.objects.filter(id=request.user.id).first()
        try:
            ret = obj.roles.all().filter(permissions__url__isnull=False).values(
                'permissions__url', 'permissions__title',).distinct()
        except Exception as e:
            print('没权限', e)
        if obj.is_superuser:
            return True
        for i in ret:
            if re.match(r"^{}".format(i['permissions__url']), url):
                # print(33333)
                return True
        # return HttpResponse('没有权限，联系管理员')
        return False

# users.models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from common.db import BaseModel
# Create your models here.

class User(AbstractUser,BaseModel):
    mobile=models.CharField(verbose_name='手机号',help_text='手机号',max_length=11,default='',blank=True)
    avatar=models.ImageField(verbose_name='头像url',help_text='头像',max_length=30,default='',blank=True)
    roles=models.ManyToManyField(verbose_name='角色',to='Role',blank=True)

    class Meta:
        verbose_name_plural='用户表'
        db_table='users'

class Role(models.Model):
    #角色表
    title=models.CharField(max_length=32)
    permissions=models.ManyToManyField(verbose_name='权限',to='Permission',blank=True)

    class Meta:
        verbose_name_plural='角色表'

    def __str__(self):
        return self.title

class Permission(models.Model):
    #权限iao
    title=models.CharField(verbose_name='标题',max_length=32)
    url=models.CharField(verbose_name='含正则URL权限',max_length=64)
    # is_menu=models.BooleanField(verbose_name='是否是菜单')
    # code=models.CharField(verbose_name='增删改查权限',max_length=32)
    # routers=models.ForeignKey(verbose_name='路径id',to='Routerinfo',on_delete=models.CASCADE,default=None,null=True)
    
    class Meta:
        verbose_name_plural='权限表'
    def __str__(self):
        return self.title
    

#users.admin.py 注册
#https://blog.csdn.net/weixin_43063753/article/details/85255907

from django.contrib import admin
from users import models
# Register your models here.

class PermissionModelAdmin(admin.ModelAdmin):
    list_display=['title','url']
    list_editable=['url']



admin.site.register(models.Permission,PermissionModelAdmin)
admin.site.register(models.Role)
admin.site.register(models.User)

#statements.views.py
from django.shortcuts import render
from rest_framework import viewsets
from statements.serializers import ItemSerializer,TaxEstiamteSerializer
from statements.models import ItemInfo,TaxEstimate
from rest_framework.permissions import IsAuthenticated
from users.permissions import UserPermissixon,RabcPermissixon
# Create your views here.

class ItemViewsSet(viewsets.ModelViewSet):
    queryset = ItemInfo.objects.all()
    serializer_class = ItemSerializer
    permission_classes=[IsAuthenticated,RabcPermissixon]

class TaxEstiamteViewsSet(viewsets.ModelViewSet):
    queryset = TaxEstimate.objects.all()
    serializer_class = TaxEstiamteSerializer
    permission_classes=[IsAuthenticated,RabcPermissixon]

#statements.urls.py
from . import views
from rest_framework.routers import DefaultRouter

# 路由列表
urlpatterns = []

router = DefaultRouter()  # 可以处理视图的路由器
router.register('items', views.ItemViewsSet)  # 向路由器中注册视图集
router.register('taxestiamtes', views.TaxEstiamteViewsSet)  # 向路由器中注册视图集


urlpatterns += router.urls  # 将路由器中的所以路由信息追到到django的路由列表中
#statements.serializers.py
from rest_framework import serializers
from statements.models import ItemInfo,TaxEstimate


class ItemSerializer(serializers.ModelSerializer):
    class Meta:
        model=ItemInfo
        fields='__all__'
        # fields=['id','username','email','mobile','avatar','last_name','roles','is_superuser']
        
class TaxEstiamteSerializer(serializers.ModelSerializer):
    class Meta:
        model=TaxEstimate
        fields='__all__'
        # fields=['id','username','email','mobile','avatar','last_name','roles','is_superuser']
#statements.models.py
from django.db import models

# Create your models here.
class TaxEstimate(models.Model):
    #纳税预计
    date=models.DateField(verbose_name='期间')
    items=models.ForeignKey('ItemInfo',on_delete=models.CASCADE)
    quantity=models.FloatField(verbose_name='数量',default='',blank=True)
    amount=models.FloatField(verbose_name='金额',blank=True)
    taxes=models.FloatField(verbose_name='税额',blank=True)

    class Meta:
        verbose_name_plural='纳税预计'

    def __str__(self):
        return self.date
    
class ItemInfo(models.Model):
    #报表项目
    item_code=models.IntegerField(verbose_name='编码',help_text='编码')
    title=models.CharField(verbose_name='项目名',help_text='项目名',max_length=32)
    category=models.CharField(verbose_name='类别',help_text='类别',max_length=32)
    class Meta:
        verbose_name_plural='报表项目'

    def __str__(self):
        return self.title